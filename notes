Very abstract Attribute Bases Access Control Model 

We have an unbounded number of attribute names, the set of which is denoted by,
                   A={a_1, a_2, ....} 

For each attribute name a_i in A, we have an associated possibly infinite domain d_{a_i}.
The set of all such domains are represented by D={d_{a_1}, d_{a_2}}.  Given an attribute 
name a_n in A, we have a total map, denoted by dom, that maps attribute names to their 
appropriate domain. Formally, dom: A -> D. 

Given the domains in D, we have a set of operators OP.
For each operator op in OP, arity(op) is its arity, and dom(op,i) is the domain of the operator for operand 1<=i<=arity(op), and dom(op) is the domain of the result of op.



Our model has an abstract authorization state, which we denote by \pi, that contains an unbounded number of entities. 
An entity is a partial mapping, denoted by \gamma_j, that maps attribute names to values from their appropriate domains.
\gamma_j : forall x \in A. dom(x) u {\bot} ??? 
An example of an entity could an object, a subject, a user, etc. As we want to enable existence of unbounded number 
of users, objects, subjects, etc., we allow to have unbounded number of entities. We denote the set of all possible states 
as \Pi. 

A request, r, is a finite sequence of attribute name-value pairs. We represent the set of all requests with R. 
Our model also have an additional component, which we call the policy function. A policy function, \psi takes 
as argument a request r and an authorization state \pi, and returns a pair <d, \pi'>, where d represents the decision 
d, where d in {Allow, Deny}, and \pi' represents a new authorization state. Formally, \Psi : R X \PI -> {Allow, Deny} X \PI. 

Abstract Language To Specify Policy Function, \Psi:

<POLICY-FUNCTION>   ::= <STATEMENTS> 
<EXPRESSION>  ::= <CONSTANT> | <IDENTIFIER> |
                                     "LET" <IDENTIFIER> "<-" <EXPRESSION> "IN" <EXPRESSION> |
                                     "IF"  "(" <CONDITIONAL-EXPRESSION> ")" "THEN" <EXPRESSION> "ELSE" <EXPRESSION> "ENDIF"
                                      "SWITCH" 


<CONDITIONAL-EXPRESSION> ::= <CONDITIONAL-EXPPRESSION> <BINARY-LOGICAL-CONNECTIVE> <CONDITIONAL-EXPRESSION> |
                  <UNARY-LOGICAL-CONNECTIVE> <CONDITIONAL-EXPRESSION> | 
                  <EXPRESSION> <BINARY-OPERATOR> <EXPRESSION> | 
                  <UNARY-OPERATOR> <EXPRESSION> 



BINARY-LOGICAL-CONNECTIVE == "AND, OR, XOR, ->"
UNARY-LOGICAL-CONNECTIVE == "!"
<BINARY-OPERATOR> = "> , < , >=, <= , =, c=, c, =), ) 


So how should we write it down..
POlicy function has two parts: Condition and Side effect. 
Condition follows the syntax and semantics of predicate-logic. 
The side effect portion has a list of two things::
    A label and a list of atomic actions.
    Label ::= ON-ALLOW | ON-DENY ...


I am thinking about the policy function to be specified in the following way:....

<CONDITION_1>: 
    ON_TRUE: <LIST OF SIDE EFFECTS> 
    ON_FALSE: <LIST OF SIDE EFFECTS>
<CONDITION_2>:  
    ON_TRUE: <LIST OF SIDE EFFECTS> 
    ON_FALSE: <LIST OF SIDE EFFECTS>
<DEFAULT>: 

OK, I understand. Makes sense.

Does a default make sense? Wouldn't you just reject?
Right...
I could see logging/auditing in an implementation, but in the abstract... :-)

Question?
Do we want the conditions to be mutually exclusive?????
Do we 
I don't see why we would force it. Would be easier if they were, but not necessary, I think.
What will be the semantics then??? 
The one you had before with SEQ, I guess. You already have an order, so do it like that.
I am not liking it for a specific reason...
I mean it looks like firewall policy...THe first one applies
What if we want something more complicated??
Example: if the first k allows it, it should be allowed?? Rather than enumerating all the conditions...
Can we have some local side effects + global one ...
If the conditions are satisfies the side effects will be carried out ..
But before the end there will be a kind of function that will take decisions for each of them and make the final decision..
We can leave it abstract ....I mean the combination part ....

OK, I see what you mean. Problems I see:
    1) That sounds like it will be hard to make any formal statements over
    2) Consistency: what if two "opposite" side effects are allowed and stuff
But sure, you could formalize something like that.
    
I mean think about the situation about HIPAA, positive norms and negative norms...
In the current semantics...We cannot encode them...
Sure you can. You just have fucked-up complicated conditions. :-)
Right ....
More like what?

Can we make an analysis problem out of it?? I mean your second point....for specific cases..
for concrete languages....Kind of like sanity checks...
Is there any request for which you will end up doing opposite things...Lets say the side effects 
have very simple format. You know the inverse of each atomic action....
Yeah, should be, but I'm not sure it's that interesting.
You'd simply look at combinations of condition-side effect pairs/triples/etc.
I mean it is better than no analysis :-) Right ...I was also thinking about giving typing judgements to ensure people write well-typed policies 
But that seems kind of difficult ...
Yeah. It depends on how well you can tell what the atomic actions are impacting. :-)

BTW, I think there's not a lot to gain by leaving the atomic actions abstract. The model only allows so much. Adding a whole entity, deleting one, adding/removing/updating attributes. Not really much else I can see...
Yeah...I was thinking along the same line ...I mean you will have add/remove entity, add/remove/update its mapping...Nothing more ...
Good thing...We leave the shitty entity abstract. For obligations, you will have an obligation entity, add shit into it...the same with logging ....
So, I concur with you on that ...Now...One more thing....How are we going to find entitys ....I mean for add/remove/update its mapping. 
Do we need a mechanism to find it. Or leave it abstract for the time being ....This will be given to us as an argument of the request ....???
????
This is the very good question. I think it depends on how the actions are specified. If we go with something like your SQL-like stuff, we could do a update-whatever-satisfies thing.

You mean: SIDE EFFECT HAVE THE FOLLOWING FORM:
    
    <SEARCH-CONDITION> : ACTION 
    Example: user=Alice /\ division = cardiology : update position=Head_Nurse...

    End effect yes, but I was also thinking with binders, so
                      user=$user /\ division = cardiology : ....
    where the binder is to the policyFunction input data

Yeah...
In a sense, it's similar to the <CONDITION>, a formula in the logic (extended to include the input), but evaluated over single entities

I know it's not pretty. But else we would need a handle to something.

What do you mean by the part "Evaluated over single entities"???
So the <CONDITION> should be able to be evaluated over the whole state. If the logic has quantifiers, you should be able to say something like: forall \lambda in \pi. \lambda.salary < input.salary
You know what I mean?

For the decision for the side effect, however, you only want it with respect to the entity you might select for an update, I think.

Let me write down in more details : ....FORMAT OF POLICY FUNCTION......(OK???) This seems fine to me.

c1 = <CONDITION_1>:
    ON_TRUE: 
<SEARCH CONDITION> : ATOMIC ACTION %%% SIDE EFFECT ...
.......................
    ON_FALSE:
................
c2 = <CONDITION_2>: 
    ...................
.
.
.
cn = <CONDITION_n>

final_decision:= policy_combiner(c1,...,cn) ; 

ON_FINAL_DECISION_TRUE:
    ...................
ON_FINAL_DECISION_FALSE:
    .................

Note February 11th, 2014..



OK? lets start??

First and most important question: 
    What is the formal definition of the safety problem?? We do not have specific stuff for users, objects, or rights???
    The problem could be defined as an entity getting an attribute??
    Or a specific entity existing?
    
    For the safety undecidability result: first we show that diophantine equation can be encoded in our condition? Hence, it is undecidable. 
    But this is not very interesting..We want to know whether we can some how loosen the condition logic and show undecidability.. For this, 
    we basically use propositional logic which is decidable. Show undecidability with that. Possibly by encoding HRU into our model???
    Makes sense??

  Yeah, would make sense. We have to see about propositional, though. :-)
Yeah, if we cannot use propositional logic to show undecidability then this is not an interesting result.
Safety being undecidable I mean....
Even with mode-checked stuff? I mean a small fragment of predicate logic?
YEah that is the alternative result we might show ...
I mean if the fucking propositional logic does not work...
I mean I was saving mode checking for showing that even with first order logic we can actually have decidability if it passes the mode check...
OK. So let's start encoding something, I guess?
Yes, exactly...

OK HRU:
    
We have subjects and objects. objects =) subjects. we have permissions...we then have the freaking matrix....
finally we have the commands:
    commands are like following: 
        (1) Take arguments...
        (2) Have a condition...
        (3) Have a unique name ..
        (4) When condition is satisfied a set of atomic actions...
        (5) Atomic actions are of form: 
            (i) CREATE PRINCIPAL/OBJECT
      (ii) DELETE PRINCIPAL/OBJECT
     (iii) ADD a right r in the cell M[s,o]
     (iv) Remove a right r from the cell M[s,o]
DONE!!!!  :-) So: trivial or obvious?

Remind me: conditions are of what form? And the creation and deletion and and s and o are specified as constants?

Conditions are boolean formula made up from the following atomic formula (You can assume conjunction of these kind of atoms) 
    a in M[s, o] or a not in M[s, o] 
    Let me check the creation...OK???
OK. Question for me is whether there's a binder. So you can refer to that new principal/object in a later atomic action.

Yes...
You do create subject s / delete subject s / create object s / delete object o 
They are bound by the input arguments...I think...
So all the s and o must be arguments? Which would be nice. :-)
They are arguments.. You can use these later ...
I mean you can do something like following

HELLO(s, o, r)
some shit condition:
    create subject s 
    create object o 
    insert r into M[s, o] 

OK. That makes at least that easy. Because we still don't have binders in the action list. :-)
Problem might be the a not in M[s,o]
Are we gonna assume a predicate for that like the bared stuff?
Yeah :-) I know where are you going ...So yes

I have several questions in general about modeling this shit ....
OK.
How are we going to keep the matrix...
Have an entity for each cell
type will be matrix-cell...
user attribute will be SUBJECT
object attribute will be OBJECT
right attribute will be "READ/WRITE/EXECUTE/OWN/MYASS"
Right attribute domain is a set??? Right...
Almost, I think.
So I think cells are good.
But we need a set-valued attribute. Else "not in" is "not exists e."
OK.
Now I don't see a problem. We should be able to do this propositional.
OK Gampa...Bigger question....Do we need some variables in the fucking shitty..<ACTION-LIST> 
so that we can save some shit in the <VARIABLE> and fucking use it later>>>
ALthough I do not see 
Of course. The search condition and values in the pairs should be able to reference the input.
I mean do we need intermediate variables....
Not for this example, I think
OK..,.....




Note : Feb 12, 2014
Encoding of HRU:
    
We have subjects and objects. objects =) subjects. 
We have a finite set of rights, R ={r1,..,rn}

finally we have the commands:
    commands are like following: 
        (1) Take arguments...
        (2) Have a condition...
        (3) Have a unique name ..
        (4) When the condition is satisfied a set of atomic actions...
        (5) Atomic actions are of form: 
            (i) CREATE PRINCIPAL/OBJECT
      (ii) DELETE PRINCIPAL/OBJECT
     (iii) ADD a right r in the cell M[s,o]
     (iv) Remove a right r from the cell M[s,o]


Conditions are a conjunction of atomic formula each of which has the following form:
a in M[s, o]    


Templates for entities:
    Subject Entity:
        {type=subject, id=..,}
    Object Entity:
    {type=object, id=...}
Right Entity: 
     {type=cell, sid=subject_id, oid= object_id, r1={true,false}, ....,rn={true,false}}    

With the existentials, it might be easier to break up the rights, let's see...

Atomic action: 
    CREATE SUBJECT s:
        CREATE entity with (type=subject), (id=s);
        CREATE entity with (type=object), (id=s); 
        ??? I was thinking to check for subject ids too when checking for object stuff, but let's see what's easier. :-) OK :D
     fuck..How do I create all rows...I mean I need to create the right entities...for all objects...
    Not with the GPL stuff. Because now you can check for existence first and create it upon ADD (so non-existence same as false)
      EXISTS e1. FORALL e2.(e1(type) = cell /\ e1(sid) = s /\ e1(oid) = s)
   What are you trying to do?
   Writing search condition for the shit ...
      Condition for what?
      Actually creating cannot be under anything ...
      OK lets ignore it for the time being ...
      If you're talking about the adding of right entities: let's do this when doing ADD. Then it's a lot easier. OK ...But again I need a guarded create right???
     Nope: you duplicate the policy rule... one for if a rights entity exists, then it's an update; one for if none exists, then it's an unconditional create
     So we have two templates or ADD r ...
   
   GOT IT :-) 
   
    CREATE OBJECT o: 
    CREATE entity with (type=object), (id=o); 
        
    DELETE SUBJECT s:
        
        ?(type=subject /\ id=s) : DELETE entity
        ?(type=object /\ id=s) : DELETE entity
        ?(type=cell /\ sid=s) : DELETE entity
        
        Question here is: do we delete the cells? I am not sure ...
        What's the semantics in HRU? Like if I have DELETE then CREATE...
        You delete the row ...
        Makes sense ....
        That should do it. Where ?() is the search condition... :-)
        
        
    DELETE OBJECT o: 
        ?(type=object /\ id=o) : DELETE entity
        ?(type=cell /\ oid=o) : DELETE entity
        Can it happen that we call that on a subject (which is implicitly an object, too)?
        I mean if somebody tells us delete an object we delete the column
        if somebody tells us delete a subject we delete the row..
        For the case delete subject where subject = object ...We just delete the subject ..not the object ...vice versa...
        Hm, OK. Is weird to me, but OK. To be honest with you, the semantics is not clear ...I mean in either case ..
        the shit is not a major change ....Yeah, that's true
        ONE of the things that has been bugging me....Tell me
        I mean from what you wrote earlier...Do we need policy conditions for the atomic actions??? 
        I do not think so. We will protect them this way, but we don't need them. Think of it as the HRU commands being a high-level language, and ours a low-level that we compile to... :-)
        I mean then what I do not understand is the following: When we have insert a right into a cell. if the cell is non-existent, we create it. Now the question is how do you do it without 
        guarding it or having a separate condition for adding it ...
        Ok. I was thinking: basic is 1 command = 1 policy rule
        Now what we can do is replicate: 1 command = x policy rules
        Then you can put the existence of the cell entity into the policy condition...
    OK got it. That is what I was thinking .....I mean the guard will be conjuncted with the policy condition itself...
         Another question: what is the basic problem of having create as a guarded command?? Makes life easy and encoding concise...Else the encoding is a fucking mess :-) 
         Sure you can do it. But you need to separate it from the others, because it's different semantics...
         Different in what sense?? It is not a search condition...
    It is just a normal condition...Question: I mean can the shitty search condition entity variable should be free? so that we can use it in the atomic action??
Good question. Thing is that makes it very powerful. So I was trying to avoid it where possible. But yeah, for a really powerful model of course a binding semantics would be awesome... :-)
If you have the binding, then it is kind of a guarded forall. So then you get back into questions about why it's undecidable, you know what I mean?
I know exactly what you mean. I mean how else are we going to have the shitty entity used in our atomic thing??
Oh, that's what you mean. OK, the entity itself is of course available. So in a sense we have exactly one binding already.
     Hmm. interesting :-) 
     Yeah, now that we talk about it, it's a little doubtful my simple explanations to myself were good... :-)
     I mean then again...
We need the binding, no matter what. The only other way:
  It's not an action list, but an action expression language. But then also no bulk updates

So you could do:
   let storeType=get(type) in
     let storeId=get(id) in ...
       delete active entity
       create entity <type=storeType,...>

And have "active' entity be just one entity from somewhere

It seems we need to do (2) first before we go do (3) 
But starting at (3) was a good idea coz we exactly know what the fuck we need 
I think it's a mix of 2 and 3. 2 alone is not good, as we need to design it so that HRU encoding keeps decidable in the right places... Which might mean that we change the encoding

Yeah...

I think currently it's more discussion about what we have. I'd hope just guarding the create is still enough.

Do we have arguments why the implicit binding with the search condition is OK?

I mean I see a definite problem. COrrect me if I am wrong. What you actually want is every entity that satisfy your search condition...then you want its binding...
Which you are going to use for performing the atomic actions..
Yes
I mean decidability is out the window :-) I mean entity countably infinite...
Do we really need countably infinite entities?
Good question..How else are you going to handle unbounded user/object??
Is that really necessary? At any point in time, you usually only see a bounded number.
We could do finite but unbouded or just finite...Finite but unbounded is good enough. You just need to ensure that the state is finite at all times, but can grow arbitrarily
Then...One good thing is that ...FOL...is decidable...oh. sorry no, we have functions..
Damn..
So that VTL has infinite x and is decidable. We can't derive anything from that?
Ok
Here was my thinking process:
    (1) DOMAIN INFINITE : to handle unbounded shit ...
    (2) LETS US USE MODE CHECKING :-) : I think we can use it for some other purpose ...for sure ..
    (3) LETS US USE full-power of FOL: undecidability is easy to show ...
    
BUt then again: it is creating unnecessary hassles ....
About finite domain VTL, we can actually derive some result, I guess..
One problem though...
Showing undecidability is never a problem... :-) Just the question of why it's undecidable and where that's coming from... :-)    
Yeah that I figured...I agree...

One thing I do not fully comprehend yet... Tell me.
We should have infinite domain for attribute values. Do you agree?? How else are we going to say: domain is natural numbers...
OK now that being said... when we want to check ... entity( attribute-name) = specific_attribute_value, how do we represent this as a proposition???? where the right hand shit could be a bounded variable...not a constant...
Even with a constant...I mean there are countably infinite shit in the attribute value domain...Do we need one proposition for each value...if yes...we need infinite set of propositions....
Comments??
I know what you mean. In a sense we don't do boolean logic. But: presburger arithmetic is decidable. So simple integer stuff must be fine.
I mean presburger arithmetic on sets is also decidable...Remember our attribute domain is shit-fully abstract ....
So I think we just need to find the right formal name for what we're using. Then countably infinite is enough, as we can encode everything into N then and do equality tests explicitly.
Is it decidable on sets over infinite domains?
What presburger arithmetic???  You said "presburger ... on sets is also decidable"
That came out wrong...I was asking a question.. I meant is it the case that it is decidable??
Oh, haha.
The good thing is: we actually only need finite sets for HRU. So there's definitely an encoding, e.g., bitmasks
Yeah, I understand....

Where were we?
We were thinking about the implicit loops of the search condition and stuff, and how we would get around it possibly. :-)
But I don't see a way. Else manipulation is really restricted.

I think entities being finite, will make the loop terminate. So, decidability is alright. Moreover, presburge shit enables us to decidably check the equality...Hence We should be alright...
Yes, if we take the state to be finite. I mean other than that I realize it does not make sense. I mean infinite state with explicit representation is not possible in real-life scenarios...
Yeah, real-life of course. :-) But we can regain it with mode-checking, if the search condition fills all free variables, somehow, I mean, it's basically the guard in a forall (phi1 -> phi2)
Just that phi2 has side effect. :-)
Yeah....I mean does it effect the decidability??? I mean we can do phi2 being a different language for atomic actions ...The only free variables are controlled by the 
mode checking judgements ...I mean in phi2..
I have no clue what it practically means. :-) I mean mode checking by itself is weird. You stipulate that there's a way, e g., a sat-solver, that can give you all solutions out of an infinite search space if you have just enough input. In practice it's clear: you have a DB or so as backend to look up. But in theory: how the fuck does that work over abstract, actually infinite stuff? Why is that computable? You know what I mean?...

I exactly know what you mean...
So I kind of think of it this way: mode checking relies on the assumption (that axiom stuff) that simply says "Yeah it's computable". So in the end we can say the same: the state might have the property that given certain inputs, the entities can be effectively retrieved and are finite amount. Like indices or something.
SOme kind key to a map..to find the value. The only problem is that it is an infinite map...
Yeah.
Anyways, back to encoding or to actions?
So you want to guard the create. That's reasonable. Just separate the things syntactically so it's very easy to separate them semantically. :-)

OK ...We can have ...

<SPECIAL-CONDITION> <CREATE-STATEMENT>
<SEARCH-CONDITION> <OTHER-STATEMENT> 

Yeah, that makes sense.

Now for the search condition...We want the entity to be a free variable with implicit universal quantification...
Well, don't know about the implicit quantification. The whole condition + statement is kind of universally quantified, but the condition itself is not. It's just for an entity that is assumed to be bound to that one variable.

I mean something like following: 
    <e(type) = "subject"/\ e(sid) = input(sid)> : INSERT (s,s1), (r, r1), ....


I would consider leaving out the quantifier, that might make it more intuitiv.
Something like that, yeah. Maybe even without the leading e. Leave e simply free.
The meaning of that whole thing would be:
    For all entity e' in state Pi, if Pi , [e', input]  |= CONDITION, then execute action with e=e' and input
Make sense?
Now I come to think of it ....
How can we check non-existence ...

 <e(type) = "cell" /\ e(s) = input(s) /\ ...) : CREATE ENTITY with (s,s1), (r, r1) , ..., a lot of random shit ...

I'd think so. If we have EXISTS for existence, then we might have \bar(EXISTS) 

OK ...

I mean question : If we are not explicitly...quantifying the "e", how the fuck do we know what we mean ...
I mean which quantifer \EXISTS or \bar{\EXISTS}, same for universal ...
No, no, no. OK. Maybe I wasn't clear.
OK, EXISTS and \bar{EXISTS} and so on only make sense when comparing for something in the state.
The non-quantified variable is for the entity we check whether we want it to be modified.

Example: Add something

I want to add attribute-value a/b to entity with id=X
In the state are entities <id=q,..>,<id=r,...>,<id=X,...>
What I envisioned the search condition doing:
    Take each entity in the state. Bind it to "e", evaluate the search condition. If the condition is true, use this entity for whatever the commands say.

<e(type) = "subject"/\ e(sid) = input(sid)> : INSERT (s,s1), (r, r1), ....    
So I can write that update as:
    ?( e(id)=X ) : INSERT(a,b)
    
What that will do semantically:
    Test whether e=<id=q,...> satisfies the search condition
    
    I understand this ....I mean very clearly
    So e doesn't need to be bound.
    
    Now if you want to compare against other elements in the state, then you need quantifiers. Like "update the one with the highest salary"
    Then you'd write ?(forall e'. e'(salary) <= e(salary) ) : ...
    
Understood ...very well :-) 
So the only thing is we need _one_ dedicated variable for this. Then the semantics is clear. It is either the substitution semantics or your environment semantics.
Got it bosss...
I mean I was thinking more of the line for CREATE ENTITY ....
OK, yeah. That is why you need the difference. :-) That whole thing of course doesn't make sense for CREATE. That one should likely simply be the same semantics of the rule condition. No implicit "e"
Yeah mang :-) Works for me ...
OK I should break
Take a dump...Then get ready for the meeting..
Don't make a mess. :-)
Not my restroom..Why do you think I care??
Because you're still a polite and decent person?

Anyways. Good luck.
I expect you'll be disappointed. But hope dies last...

lol :-) I am most probably gonna write down the shit ...
One last thing before I go...
I mean these atomic actions semantics ...Can we just say that these shit are all fucking dependent on fucking domain of the attribute value ....
I mean INSERT means replace for atomic, union for set, append for list ...
Yeah, I think that is perfectly fine. You say it has some computable meaning, with the expected being ...

OK
Now the condition .....
In the conditions do we need to check subset and shit?? or substring or my ass ?? 
We need membership, maybe, depending on encoding of sets. You had your role sets in sessions, too. So that might be necessary.

Again with the stipulation that they are finite it's easy.

Now I come to think of it ...Roles can single attribute ...with domain true, false, bot ....
That needs you to refer to attributes names as computed values. Right now the e(x) has x as a "constant"
To write meaningful policies, you'd likely need that to also take a variable or even expression

Exactly :-) OK More later...dump coming ....
You don't care about your office either, so just let it go. :-)

OK.
Ping me.
I'll be driving to Rocky's from 4 to 5 (or Apostolos will)
So we could keep chatting.
Though no Etherpad on the phone...


    ADD r to the cell M[s, o]
    
      CASE 1: cell with sid=s and oid=o exists
      CASE 2
        
    DELETE r from the cell M[s, o]



Note:
(1) Distributed systems (scope our work to centralized system or mention shit is abstracted away)
(2) Role, user, attribute, object hierarchy ...
(3) Attribute inference ....
(4) Attribute creation and deletion ...
(5) Infinite number of entities?? 
(6) Think about group shit ...
(7) Examples ...
(8) Encoding of other access control models..
(9) Environment ..
(10) patient policies ...
(11) constraints ...



Look for a fixed-point logic ...First order fixed point would be nice ...
Note that given ground instances ... we are going to check whether it is 
satisfied ... We are not going to check whether some specific formula is 
valid or not ...

Make request an entity too....But then comes the shit about whether they 
are also stored in the state ....May be we can delete it at the end of the 
execution of the policy function ...Again the question is ...

For convenience, we assume request to be an entity too. However, this is an 
special kind of entity which is not stored as part of the authorization state 
and also the creation and deletion of it is unrestricited and out of the scope. 


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Policy Machine Model 
Policy Combination ...
Policy Consistency ...
Language for Policy Decision Combination ...Now it is kept abstract ....

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Notes : March 11, 2014 ...
The goal I had in mind till now is the following: 
    
    Have an abstract model and an abstract language....
    Then instantiate this abstract model and language 
    with concrete instantiation, something like Ninghui's 
    and show that different well-known AC models can 
    be captured in these concrete model. 
    
    We prove safety and some other analysis problems 
    for these concrete models. I am thinking most of them 
    will be either intractable (or, undecidable).  I agree.
    
    
    We have already come up with an abstract model 
    We kind of came up with an abstract language
    But it is not yet done ...
    
    I mean the question I have is how abstract is abstract enough 
    but still is meaningful to have kind of idea about what is going 
    on. 
    
    I mean for consistency checking and shit ...We need a language 
    for the policy combining function which is the (+) in the language. 
    
    I mean I also want kind of an access control scheme which will be 
    a tuple <....,language(some logic for expressing the conditions)> 
    I understand what you mean and agree.
    This also gives a good way to classify schemes. And hopefully
    allows simple complexity hierarchies.
    
    This will enable us to have the concrete model without having to 
    explain what is happening. For instance, 
    
    Perfect !!!! 
    As usual, the devil is in the details. :-) As in: what is a good basic
    instantiation...
    
    What would be great is if we can show lots of things for a very simple scheme.
    Where we can basically map domains to N, and have a simple thing like the Presburger
    thing we talked about for the logic.
    
    (Great is viewpoint dependent. If we show safety is undecidable there already... :-) )
    
    Understood
    
    Say this is the most general model....OK
    <A, D_A, \delta, \pi, \psi, L(logic, {creation, deletion, update})> 
    
   The first concrete model Ninghui had does not have any state associated with it...
   
   In which case it will be: 
       This is S_0 or M_0
       <A, D_A, \delta, EMPTY, \psi, L(proposition logic, {})>  
       
  I don't see where that simplifies significantly in our model, as we might be able to encode all
  that \pi shit into tuples...
  Can you explain why you think it makes things simpler?
  
I mean this is a static policy that only checks whether the request attributes-values matches with some 
constants ....

You have no state ...no atomic actions ....Just check condition which is a boolean combination of 
equalities ....???

Request(user-id) == "omar" /\ Request(role-id) == "Doctor" /\ Request(object-id) == "Prescription" 
Is 'Request" the only thing that makes this FOL?
Actually fuck
I made a mistake it should only be propositional logic ....Now ???
OK.
I can see that.
This is basically what XACML allows ....Static shit ...
I thought it has "entrypoints' for the environment. No functions or predicates?
You mean XACML??? Yes.

I mean it has PIP ...which gather attributes ...But the fucking policy rules 
are in general staticc ....Does not tell you how to handle dynamic conditions or no side effects except obligations ...
But it means the meaning of the policy can vary, doesn't it?
Hmmm
I mean but it is kept as abstract ...
I kind of know what you mean. I am just asking. Because depending on the power of those PIP things,
the power of the policy changes.
Say you have a simple predicate p(x,y) in your policy.
That might be something trivial like ==, or it might be the halting problem.
That's why I'm never too sure about this. But I understand that this is the weakest category. At least if you fix
for computable predicates as in PIP.

Let me double check something real quick. I understand what you mean....

YEah....You are right...A better example is firewall policies ....

Where you provide source and destination information and tell you whether something is allowed .....
XACML cannot be viewed as the concrete instantiation of this model ....unless you fix the predicates 
to be decidable ....Moreover, Assuming PIP is outside the system's model ....But that is a discussion 
we should not get into. Firewall policies are alright examples of this model. 
OK, sounds good.

QUestion: What would be safety for this model :-) 
Good question. :-) What did Ninghui do? :-)
He does not have anything related to safety ....
I mean safety does not make sense IMHO ....
We can ask questions like the ones we talked about last night ...
Will this guy have access to this shit ...provided that his shit (attributes)  does not change ....
Yes.
But it should be very unimpressive, it seems. :-)
Yeah :-) 
You can do it in linear time of the policy rules :-) 
:-) Great, we have a P model. :-) hahahah :-) Tell me about it ...Everything is static ...

What would be the natural expansion? Actions or state?

I mean the next progression???? 

M_1/S_1/or my_ass_1 whatever: 
You can have append shit ...that is create shit....+ you need state .... (IMMUTABLE MODEL)
OK.
What's your guess at complexity of safety?

Monotonic system ...There is classic result for it ....Let check real quick ...

Decidable ...in NP possibly...HRU for monotonic shit is decidable but intractable ...
That seems a good progression, though. Not too big a jump.
Yeah...Our system is mono-operational and monotonic, right ???
Mono-operational in the sense that it only allows creation ...Hence it should be in NP ....I Mean decidable ...
We should investigate for NP.
Else I agree with you. Algorithm is likely the one for Chomsky-1 languages: just generate states, which will
always increase.
Though you'd have to assume that from each state there are only finite number of successors.
(or at least you only need to investigate a final number)
Yeah ....I understand ...

Anyhow M_2/S_2/or MY_ASS_2 is MUTABLE ...
 <A, D_A, \delta, \pi, \psi, L(FOL, {creation, deletion, update})> 
 
 This should be easy to show that the fuck is undecidable :-) Likely. :-)

OK. Are we doing the progression that we sketched out before?

Then we can go one level up ...

M_3/S_3/ ....
 <A, D_A, \delta, \pi, \psi, L(FOL + FIXED POINT OPERATOR, {creation, deletion, update})> 
 
 FOR FOL, I am thinking about loosely-guarded fragment ....
 
 FORALL x.( /\atomic-formula -> formula) ...
EXISTS  x.( /\atomic-formula /\ formula) ...

This is generally decidable + expressive enough ....Other decidable fragments are not expressive enough ....
OK, I have to defer to your knowledge and judgment here.

But fucking fixed point logic ...shits it up :-) 
 Without fixed point operators we cannot express fucking Role-based access control ...I mean the hierarchical ones ...
 This is what I am worried about ...
 Yeah, I know.
 
This needs figuring out ...I will do it ...

Finally, We were talking about expression language for the shit ........
May be I should do this first and talk to you about it over the weekend. 

I mean write out everything then talk about it over the weekend...Hence 
I will have more concrete questions ...

That sounds reasonable.
I think to remember we started trying to instantiate some models.
I think the expression language goes into this direction and would give us hints on what we might be missing.


March 17th, 2014
++++++++++++++++
=============================================================================================================

OK: We denote policy function by \Psi. \Psi is parameterized. 

\Psi( L_c, L_pc, A) :-
L_c => Language for expressing conditions 
L_pc => Language for policy combination 
A => Set of allowed atomic actions (create, destroy, insert, delete, update) 

The semantics of A is defined by the domain of the attribute name: set, atomic, list .... 



begin
c1  <= EVAL COND ϕ1
ON-TRUE : <ACTION-LIST>
ON-FALSE : <ACTION-LIST>
...
...
cn  <= EVAL COND ϕn
ON-TRUE : <ACTION-LIST>
ON-FALSE : <ACTION-LIST>

ρ <=  L(c1, . . . , cn)

ON-ALLOW : <ACTION-LIST>
ON-DENY : <ACTION-LIST>
end


<ACTION-LIST> ::=   <CREATION-ACTION><ACTION-LIST> 
                                   | <OTHER-ACTION><ACTION-LIST> | Empty
                  
<CREATE-ACTION> ::= <SOME-COND> “CREATE ENTITY WITH ” <ATT-VAL-LST>

<OTHER-ACTION> ::= <SEARCH-COND> “:” <ATOMIC-ACT-LST>

<ATOMIC-ACT-LST> ::= <ATOMIC-ACTION> <ATOMIC-ACT-LST> | Empty

<ATOMIC-ACTION> ::=   “DELETE ENTITY” 
                    | “INSERT”<ATT-VAL-LST>
                    | “DELETE”<ATT-LST>
                    | “UPDATE”<ATT-VAL-LST>

<ATT-VAL-LST> ::=   “(”<NAME>“,”<TERM>“)” “;”<ATT-VAL-LST> 
                  | “(”<NAME>“,”<TERM>“)” 
                  
<ATT-LST> ::= <NAME>“,”<ATT-LST> | <NAME>

This seems reasonable to me. Questions would now be about semantics, mainly the separate action lists. For example, do the action lists of c1-cn
get executed immediately, or when the final ON-ALLOW/DENY is done.

The separate action list is useful for logging purposes. When you are trying to create an entity, it will be effected in the final 
ON_ALLOW: block 

You can say stuff like, if anybody satisfies or falsifies certain condition, I want to log this information ...
Then you can use the regular shit. .....
But now I come to think of it...I am not at all sure....whether this is of any use?

What do you say? 
I think it's OK. But it doesn't answer my question. :-) Or at least you're talking around it. So assume the condition for c1 is true. Do you execute the actions,
no matter ON-ALLOW or ON-DENY?

The idea is if a condition is true/false, the corresponding action of the true/false block will get executed...
It is independent of the final decision (ALLOW/DENY)
This is the semantics I had in mind ...Hence the logging example ....
This answers your question? 
Yes. Thanks.

Now, two things.....

How would the condition for the create entity would look like?

Answer: 
               FORALL_e e. (e(name) != r(name) \/ e(sid) != r(sid)). : create entity E_new 
                                       
What are you trying to encode here?
Actually I do not see anything :-) 
I was thinking about the old syntax ....
I was thinking: after a create entity you would need a insert command which has a search condition in it. 
Now I am come to think of it... it is not actually necessary....because create entity takes arguments for attribute values 
with which he needs to create the entity...That kind of solves the initial problem I thought we had ....
Yes. You need parameters, else we have weird "uninitialized" tuples. You can work around that, but it's simply a lot easier
and cleaner to just give parameters.
One more question: What should be the syntax for the guard of the create command: 
    Just like the condition in the rules...A closed formula in L_c ???? 
    I think it is just a regular condition like in all the other things. I am not sure about closed. Closed might be too restrictive as
    you can't match against existing tuples. If you can't match, you can't write generic rules. Like: if there is a patient with name x,
    create a patient record with name x. You know what I mean? You would have to encode that into the request...

I have a question then. If the condition guarding the create command is exactly like the search condition, why are we differentiating between CREATE entity and other atomic actions? 
Good question. Did we write down a reason before? :-)

Let me check our notes, real quick :-) 

Nope, it seems we did not write down a reason ....We were going on Tangantial discussion ....LET ME LOOK A LITTLE MORE DEEPLY.................. :-)

 OMAR: Another question: what is the basic problem of having create as a guarded command?? Makes life easy and encoding concise...Else the encoding is a fucking mess :-) 
ANDREAS:         Sure you can do it. But you need to separate it from the others, because it's different semantics..

Something to do with the HRU encoding ..... ????
Crap, I don't remember. :-) Oh, I think the thing was:
    
    The normal semantics is that you _repeat_ the condition for every tuple in the state, and when it applies, execute the commands. This way you can do
    bulk update and delete. But you don't want that for CREATE. So the condition looks exactly the same, but the meaning is different. I think that was it.

Boss. I do not get it. ..........I mean the semantics.... Let me tell you where ......
You are saying : for all non-create we want bulk operations ...which can be done by universally iterating over the entities ....which makes sense ...
Now for the CREATE shit: You first evaluate the condition fully ??? then do the create ....???Tell me the create shit again please ....
OK. Before we somehow had that stuff like UPDATE and DELETE should be able to apply to multiple tuples in one go. That is done by
implicitly looping over all tuples in the state, binding it, evaluating the condition, and if it applies, executing the actions.

Now, for create, it seems that the usual meaning is that you want to create _exactly one_ new tuple. So any looping is not what we want.

Then we basically want a closed formula with the language L_C => same language as the rule condition 
I think so. Difference seems to be open vs closed. But even if it is closed, you need to say you're not iterating. Else the closed formula will
trivially apply to all tuples in the state if it is true, and you might create that many new tuples (except if we can enforce that the new tuples
are all the same, and set semantics takes care of duplicates). But yes, the base language could be exactly the same.

Maybe it is actually easier to postpone that to the discussion of the semantics, and have the syntax uniform. As it does look identical...

Let me read what you wrote:  "But even if it is closed, you need to say you're not iterating" => what do you mean by this???
OK. So iterating is meaningful if you can somehow remember something for the current iteration. Your loop counter. In a sense,
that is a predefined variable in the formula, like the "e" you had, and it should be preserved between condition and action execution.
Only then can you meaningfully delete crap, for example. "I want to delete all tuples with name=Omar".

OK. Now one could think that if a formula is closed, that is, is not using this binding mechanism, it doesn't want to iterate. The create,
for example, doesn't need to. If you want to create a single static tuple. Like: "If the request says create Omar, create Omar." Doesn't
use the iterator variable. So it is, in a sense, closed.

But you would still have to say that you are not iterating over the tuples in the state. Else the closed formula applies to all of them if it is satisfied by itself.

Got it ....Perfectly .... But what about we want to create shit in Bulk?? like sessions??? What then??? 
OK, I have no example. Can you write one, while I run to the restroom? :-)



How would the search condition for the insert/delete/update would look like???

Answer: 
    (e(name) = $name /\ e(sid) = $sid /\ e(salary) >= $salary : update (e.salary, 10K) 

e is universally quantified ...quantifies the entities in the state 
$salary => value of salary mapped by the request ... 

Sounds good to me.
If you want to go without variables, you could define a name for the request tuple and make it x(salary).
OK. sounds good to me. 

Now we were talking about expression language. Is that for the create entity shit .... 


====================================================================================================
ENCODING OF HRU IN OUR MODEL 
====================================================================================================
EACH COMMAND WILL BECOME ONE POLICY RULE ...

R is the request ...

R(command_name) = "C_1" /\ additional condition (see below) ....

Condition of the form  "r in M[s, o]" will be translated to : 
EXISTS_ENTITY e1. e(type) = cell /\ e(sid) = R(sid) /\ e(oid) = R(oid) /\ {R(r)} \subseteq e(permission_set)


ON_PERMIT and ON_DELAY block will be empty ....

POLICY COMBINATION FUNCTION WILL BE A DISJUNCTION OF ALL THE COMMANDS ....
===========================================================================================================

Templates for entities:
    Subject Entity:
        {type=subject, id=..,}
    Object Entity:
    {type=object, id=...}
Right Entity: 
     {type=cell, sid=subject_id, oid= object_id, available_permissions={...}}    


CREATE PRINCIPAL : 

FORALL_ENTITY e1.( e1(type) = subject => e1(id) != R(id) ) : 
CREATE ENTITY WITH (type, subject) ; (id , R(id)) 

e(type) = object => e(id) = R(id) :
    CREATE ENTITY WITH (type, object) ; (id, R(id)) 

e(type) = object : 
    CREATE ENTITY WITH (type, cell) ; (sid, R(id)) ; (oid, e(id)) 

e(type) = subject: 
    CREATE ENTITY WITH (type, cell) ; (oid, R(id)) ; (sid, e(id)) 



CREATE OBJECT:

FORALL_ENTITY e1.( e1(type) = object => e1(id) != R(id) ) : 
CREATE ENTITY WITH (type, object) ; (id , R(id)) 

e(type) = subject: 
    CREATE ENTITY WITH (type, cell) ; (oid, R(id)) ; (sid, e(id)) 


DELETE PRINCIPAL: 

e(type) = subject /\ e(id) = R(id) : 
    DELETE ENTITY e ;

e(type) = object /\ e(id) = R(id) : 
    DELETE ENTITY e ;

e(type) = cell /\ ( e(sid) = R(id) \/ e(oid) = R(id)): 
DELETE ENTITY e; 


DELETE OBJECT:    

e(type) = object /\ e(id) = R(id) : 
    DELETE ENTITY e ;

e(type) = cell /\  e(oid) = R(id): 
DELETE ENTITY e; 



ADD a right "r" to the cell M[s, o]:

e(type) = cell /\ e(sid) = R(sid) /\ e(oid) = R(oid): 
INSERT INTO e VALUE (permission_set, e(permission_set) UNION {R(right)}

REMOVE a right "r" to the cell M[s, o]:

e(type) = cell /\ e(sid) = R(sid) /\ e(oid) = R(oid): 
UPDATE e WITH VALUE (permission_set, e(permission_set) SETMINUS {R(right)}

